
                       EC440, project 1
		         Evan Bowman
		        ebowman@bu.edu
			  U42410036

OVERVIEW
  My shell implementation is fairly straightforward, and supports
  all of the functionality as required by the project guidelines.
  As with most interpreters, my code is  more or  less structured
  around a REPL; the  program populates a buffer with input  from
  the user, tokenizes and parses  it, evaluates the commands, and
  then prints the response.

IMPLEMENTATION
  The core datastructures that I used are fairly straightforward,
  mostly  arrays,  and some  vectors (I implemented  an interface
  similar to C++'s stl vector  class in order to  abstract memory
  allocation in C).

  In order to parse  the input, I used  a combination of  a lexer
  generated by flex(1), and a simple hand-written parser.

  In order to launch processes, I followed the standard fork/exec
  strategy,  while  duplicating  and closing file  descriptors as
  needed for I/O redirection.

ISSUES
  The only  issues that I  ran into were  with correctly creating
  pipes between  child  processes. I  did not  realize that  when
  creating pipes in the parent process and calling fork, I needed
  to close  the file descriptors for not  only the unused ends of
  the pipes required by a particular child, but for all the  file
  descriptors  inherited from the  parent process.  Otherwise the
  first pipe would work, but  then any additional pipes after the
  second command would hang indefinitely.

(1) https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)
